<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flakkaqi.github.io</id>
    <title>祁先生的微博客</title>
    <updated>2021-04-20T06:37:08.216Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flakkaqi.github.io"/>
    <link rel="self" href="https://flakkaqi.github.io/atom.xml"/>
    <subtitle>You dida dida me , I huala hula you</subtitle>
    <logo>https://flakkaqi.github.io/images/avatar.png</logo>
    <icon>https://flakkaqi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 祁先生的微博客</rights>
    <entry>
        <title type="html"><![CDATA[maven将本地jar包安装到仓库]]></title>
        <id>https://flakkaqi.github.io/post/maven-jiang-ben-di-jar-bao-an-zhuang-dao-cang-ku/</id>
        <link href="https://flakkaqi.github.io/post/maven-jiang-ben-di-jar-bao-an-zhuang-dao-cang-ku/">
        </link>
        <updated>2020-11-18T02:16:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code>mvn install:install-file -Dfile=aspose-words-16.8.0-jdk16.jar -DgroupId=com.aspose -DartifactId=aspose-words -Dversion=16.8.0 -Dpackaging=jar
</code></pre>
<p>mvn install:install-file -Dfile=pageoffice4.5.0.10.jar -DgroupId=com.zhuozhengsoft -DartifactId=pageoffice -Dversion=4.5.0.10 -Dpackaging=jar</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[缓存的三大问题]]></title>
        <id>https://flakkaqi.github.io/post/huan-cun-de-san-da-wen-ti/</id>
        <link href="https://flakkaqi.github.io/post/huan-cun-de-san-da-wen-ti/">
        </link>
        <updated>2020-10-27T06:20:13.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇文章主要谈谈Redis中很容易出现的三大问题现象：缓存击穿、缓存穿透以及缓存雪崩。不过在介绍这三个问题现象之前，我们首先需要先来了解下Redis中key的过期淘汰机制。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇文章主要谈谈Redis中很容易出现的三大问题现象：缓存击穿、缓存穿透以及缓存雪崩。不过在介绍这三个问题现象之前，我们首先需要先来了解下Redis中key的过期淘汰机制。</p>
<!-- more -->
<p>😁众所周知，Redis可以对存储在Redis中的缓存数据设置过期时间，比如我们获取的短信验证码一般十分钟过期，我们这时候就需要在验证码存进Redis时添加一个key的过期时间，但是这里有一个需要格外注意的问题就是：并非key过期时间到了就一定会被Redis给删除。那么Redis是如何做到对过期key进行删除呢？Redis中对于过期key的删除分为两种策略：定期删除和惰性删除。</p>
<p><em>定期删除</em>：Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 Key，检查其是否过期，如果过期就删除。为什么是随机抽取而不是检查所有key？因为你如果设置的key成千上万，每100毫秒都将所有存在的key检查一遍，会给CPU带来比较大的压力。</p>
<p><em>惰性删除</em> ：定期删除由于是随机抽取可能会导致很多过期 Key 到了过期时间并没有被删除。所以用户在从缓存获取数据的时候，redis会检查这个key是否过期了，如果过期就删除这个key。这时候就会在查询的时候将过期key从缓存中清除。<br>
😙但是如果仅仅使用定期删除 + 惰性删除机制还是会留下一个严重的隐患：如果定期删除留下了很多已经过期的key，而且用户长时间都没有使用过这些过期key，导致过期key无法被惰性删除，从而导致过期key一直堆积在内存里，最终造成Redis内存块被消耗殆尽。那这个问题如何解决呢？这个时候Redis内存淘汰机制应运而生了。Redis内存淘汰机制提供了6种数据淘汰策略：</p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时移除最近最少使用的key。</li>
<li>allkeys-random：从数据集中任意选择数据淘汰。</li>
<li>no-enviction：当内存不足以容纳新写入数据时，新写入操作会报错</li>
</ul>
<p>😠一般情况下，推荐使用volatile-lru策略，对于配置信息等重要数据，不应该设置过期时间，这样Redis就永远不会淘汰这些重要数据。对于一般数据可以添加一个缓存时间，当数据失效则请求会从DB中获取并重新存入Redis中。</p>
<p>###缓存击穿</p>
<p>讲完了Redis的key的过期淘汰机制，接下我们可以进入正题：为什么会出现缓存击穿、缓存穿透和缓存雪崩现象呢？首先我们来看下请求是如何取到数据的：当接收到用户请求，首先先尝试从Redis缓存中获取到数据，如果缓存中能取到数据则直接返回结果，当缓存中不存在数据时从DB获取数据，如果数据库成功取到数据，则更新Redis，然后返回数据，如果DB无数据，则返回空结果。那什么情况下会出现三大问题现象呢？我们先来看下缓存击穿的情况：</p>
<ul>
<li>定义：高并发的情况下，某个热门key突然过期，导致大量请求在Redis未找到缓存数据，进而全部去访问DB请求数据，引起DB压力瞬间增大。</li>
<li>解决方案：缓存击穿的情况下一般不容易造成DB的宕机，只是会造成对DB的周期性压力。对缓存击穿的解决方案一般可以这样：Redis中的数据不设置过期时间，然后在缓存的对象上添加一个属性标识过期时间，每次获取到数据时，校验对象中的过期时间属性，如果数据即将过期，则异步发起一个线程主动更新缓存中的数据。但是这种方案可能会导致有些请求会拿到过期的值，就得看业务能否可以接受，如果要求数据必须是新数据，则最好的方案则为热点数据设置为永不过期，然后加一个互斥锁保证缓存的单线程写。</li>
</ul>
<p>###缓存穿透</p>
<ul>
<li>定义：缓存穿透是指查询缓存和DB中都不存在的数据。比如通过id查询商品信息，id一般大于0，攻击者会故意传id为-1去查询，由于缓存是不命中则从DB中获取数据，这将会导致每次缓存都不命中数据导致每个请求都访问DB，造成缓存穿透。</li>
<li>解决方案：缓存穿透的解决方案可以分成两个部分：首先在API层增加基本校验：用户鉴权校验，id校验。比如用户鉴权失败或者id &lt; 0的请求直接进行拦截。其次在缓存和DB都取不到数据的时候将将key-value存储成key-null存储到Redis， 过期时间可以存储的短点比如60S，防止短时间内攻击者不断发起请求导致数据库压力过大出现宕机。</li>
</ul>
<p>###缓存雪崩</p>
<ul>
<li>定义：缓存中如果大量缓存在一段时间内集中过期了，这时候会发生大量的缓存击穿现象，所有的请求都落在了DB上，由于查询数据量巨大，引起DB压力过大甚至导致DB宕机。</li>
<li>解决方案：缓存雪崩一般没有完美解决的方法，但是我们可以尽量分析用户行为，尽量保证key的失效时间比较平均，防止同一时间出现大量缓存数据同时过期的现象，并且设置热点数据永不过期。同时如果为分布式环境下，使用分布式锁来保证缓存的单线程写，这样可以避免同一时间大量缓存失效导致请求全部落在DB上。而我觉得如果可以接受有些请求拿到过期值，最合理的方案实际上就是使用缓存击穿的方案：Redis中的数据不设置过期时间，然后在缓存的对象上添加一个属性标识过期时间，每次获取到数据时，校验对象中的过期时间属性，如果数据即将过期，则异步发起一个线程主动更新缓存中的数据。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot解决跨域问题]]></title>
        <id>https://flakkaqi.github.io/post/springboot-jie-jue-kua-yu-wen-ti/</id>
        <link href="https://flakkaqi.github.io/post/springboot-jie-jue-kua-yu-wen-ti/">
        </link>
        <updated>2020-09-27T01:47:28.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>什么是跨域问题这里我就不说了，直接说我使用addCorsMappings方法配置跨域时遇到的问题。具体代码如下：</p>
<pre><code class="language-java">public void addCorsMappings(CorsRegistry registry) {
   
    registry.addMapping(&quot;/**&quot;)
            .allowedOrigins(&quot;*&quot;)
            .allowedMethods(&quot;POST&quot;, &quot;GET&quot;, &quot;PUT&quot;, &quot;OPTIONS&quot;, &quot;DELETE&quot;)
            .allowCredentials(true)
            .allowedHeaders(&quot;*&quot;)
            .maxAge(3600);
}
</code></pre>
<p>但是使用此方法配置之后再使用自定义拦截器时跨域相关配置就会失效。<br>
原因是请求经过的先后顺序问题，当请求到来时会先进入拦截器中，而不是进入Mapping映射中，所以返回的头信息中并没有配置的跨域信息。浏览器就会报跨域异常。</p>
<p>正确的解决跨域问题的方法时使用CorsFilter过滤器。代码如下：</p>
<pre><code class="language-java">private CorsConfiguration corsConfig() {
    CorsConfiguration corsConfiguration = new CorsConfiguration();
    * 请求常用的三种配置，*代表允许所有，当时你也可以自定义属性（比如header只能带什么，只能是post方式等等）
    */
    corsConfiguration.addAllowedOrigin(&quot;*&quot;);
    corsConfiguration.addAllowedHeader(&quot;*&quot;);
    corsConfiguration.addAllowedMethod(&quot;*&quot;);
    corsConfiguration.setAllowCredentials(true);
    corsConfiguration.setMaxAge(3600L);
    return corsConfiguration;
}
@Bean
public CorsFilter corsFilter() {
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration(&quot;/**&quot;, corsConfig());
    return new CorsFilter(source);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot如何配置RedisTemplate]]></title>
        <id>https://flakkaqi.github.io/post/springboot-ru-he-pei-zhi-redistemplate/</id>
        <link href="https://flakkaqi.github.io/post/springboot-ru-he-pei-zhi-redistemplate/">
        </link>
        <updated>2020-08-13T09:08:29.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="一-引入依赖">一、引入依赖</h2>
<pre><code class="language-xml">&lt;!--redis--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!--fastjson--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;fastjson&lt;/artifactId&gt;
			&lt;version&gt;1.2.47&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<h2 id="二-新建配置类">二、新建配置类</h2>
<pre><code class="language-java">
import com.alibaba.fastjson.support.spring.FastJsonRedisSerializer;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.data.redis.RedisProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
public class RedisConfig {

    @Bean
    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(
            RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        //使用fastjson序列化
        FastJsonRedisSerializer fastJsonRedisSerializer = new FastJsonRedisSerializer(Object.class);
        // value值的序列化采用fastJsonRedisSerializer
        template.setValueSerializer(fastJsonRedisSerializer);
        template.setHashValueSerializer(fastJsonRedisSerializer);
        // key的序列化采用StringRedisSerializer
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    @Bean
    @ConditionalOnMissingBean(StringRedisTemplate.class)
    public StringRedisTemplate stringRedisTemplate(
            RedisConnectionFactory redisConnectionFactory) {
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }
}
</code></pre>
<h2 id="三-添加redis配置文件">三、添加redis配置文件</h2>
<pre><code class="language-yml">spring:
  # Redis数据源
  redis:
    #database为默认redis创建的0-15个db数据库，这里默认为0，只用填写数字
    host: localhost
    port: 6379
    timeout: 500
    password: 123456
    jedis:
      pool:
        max-active: 5  # 连接池最大连接数（使用负值表示没有限制）
        max-wait: -1      # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-idle: 20      # 连接池中的最大空闲连接
        min-idle: 1       # 连接池中的最小空闲连接
</code></pre>
<h2 id="四-扩展工具类">四、扩展工具类</h2>
<pre><code class="language-java">package com.css.zjjg.common.utils;

import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * @author QiShuai
 * @date 2020/8/13 13:53
 * @description redis工具类
 */
@Component
public final class RedisUtil {

    @Resource
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public Set&lt;String&gt; keys(String keys) {
        try {
            return redisTemplate.keys(keys);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 指定缓存失效时间
     *
     * @param key  键
     * @param time 时间(秒)
     * @return
     */
    public boolean expire(String key, long time) {
        try {
            if (time &gt; 0) {
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     *
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }

    /**
     * 判断key是否存在
     *
     * @param key 键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key) {
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除缓存
     *
     * @param key 可以传一个值 或多个
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void del(String... key) {
        if (key != null &amp;&amp; key.length &gt; 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    /**
     * 普通缓存获取
     *
     * @param key 键
     * @return 值
     */
    public Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     *
     * @param key   键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 普通缓存放入并设置时间
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */
    public boolean set(String key, Object value, long time) {
        try {
            if (time &gt; 0) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } else {
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 递增
     *
     * @param key   键
     * @param delta 要增加几(大于0)
     * @return
     */
    public long incr(String key, long delta) {
        if (delta &lt; 0) {
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 递减
     *
     * @param key   键
     * @param delta 要减少几(小于0)
     * @return
     */
    public long decr(String key, long delta) {
        if (delta &lt; 0) {
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    /**
     * HashGet
     *
     * @param key  键 不能为null
     * @param item 项 不能为null
     * @return 值
     */
    public Object hget(String key, String item) {
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     *
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object, Object&gt; hmget(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     *
     * @param key 键
     * @param map 对应多个键值
     * @return true 成功 false 失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * HashSet 并设置时间
     *
     * @param key  键
     * @param map  对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value, long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     *
     * @param key  键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item) {
        redisTemplate.opsForHash().delete(key, item);
    }

    /**
     * 判断hash表中是否有该项的值
     *
     * @param key  键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item) {
        return redisTemplate.opsForHash().hasKey(key, item);
    }

    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * @param key  键
     * @param item 项
     * @param by   要增加几(大于0)
     * @return
     */
    public double hincr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, by);
    }

    /**
     * hash递减
     *
     * @param key  键
     * @param item 项
     * @param by   要减少记(小于0)
     * @return
     */
    public double hdecr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, -by);
    }

    /**
     * 根据key获取Set中的所有值
     *
     * @param key 键
     * @return
     */
    public Set&lt;Object&gt; sGet(String key) {
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key   键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key, Object value) {
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将数据放入set缓存
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 将set数据放入缓存
     *
     * @param key    键
     * @param time   时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key, long time, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if (time &gt; 0) {
                expire(key, time);
            }
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 获取set缓存的长度
     *
     * @param key 键
     * @return
     */
    public long sGetSetSize(String key) {
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 移除值为value的
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 移除的个数
     */
    public long setRemove(String key, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    // ===============================list=================================

    /**
     * 获取list缓存的内容
     *
     * @param key   键
     * @param start 开始
     * @param end   结束 0 到 -1代表所有值
     * @return
     */
    public List&lt;Object&gt; lGet(String key, long start, long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 获取list缓存的长度
     *
     * @param key 键
     * @return
     */
    public long lGetListSize(String key) {
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 通过索引 获取list中的值
     *
     * @param key   键
     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     * @return
     */
    public Object lGetIndex(String key, long index) {
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return
     */
    public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value, long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据索引修改list中的某条数据
     *
     * @param key   键
     * @param index 索引
     * @param value 值
     * @return
     */
    public boolean lUpdateIndex(String key, long index, Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 移除N个值为value
     *
     * @param key   键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */
    public long lRemove(String key, long count, Object value) {
        try {
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 根据key前缀批量删除缓存
     * @param key
     * @return
     */
    public long batchDel(String key){
        try {
            Set&lt;String&gt; keys = redisTemplate.keys(key + &quot;*&quot;);
            Long delete = redisTemplate.delete(keys);
            return delete;

        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://flakkaqi.github.io/post-images/1597310054821.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java中堆栈的区别]]></title>
        <id>https://flakkaqi.github.io/post/java-zhong-dui-zhan-de-qu-bie/</id>
        <link href="https://flakkaqi.github.io/post/java-zhong-dui-zhan-de-qu-bie/">
        </link>
        <updated>2020-06-25T01:59:13.000Z</updated>
        <summary type="html"><![CDATA[<p>zzzd</p>
]]></summary>
        <content type="html"><![CDATA[<p>zzzd</p>
<!-- more -->
<h3 id="一-撇开静态存储分配集中比较堆和栈">一、撇开静态存储分配,集中比较堆和栈</h3>
<p>功能和作用</p>
<pre><code>堆：主要是用来存放对象的
        缺点：程序运行时请求操作系统给他分配内存，比如多态，系统分配和销毁内存时占用时间长，效率低。
        优点：编译器不必知道要从堆里分配多少空间，也不需要知道要在堆里停留多久，
栈：主要是用来执行程序的
        优点：保存对象的引用和基本数据类型、局部变量、形式参数等在栈中分配内存，编译时数据区的大小已经确定，运行时分配，大小不变，分配速度快。销毁时只需要移动栈指针即可，速度快。
</code></pre>
<h3 id="二-jvm中的堆和栈">二、JVM中的堆和栈</h3>
<pre><code>    JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈;
 对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈 以帧为单位保存线程的状态;
    JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作；
 从Java的这种分配机制来看:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性；
 每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享；
    Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已；
 Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。
 基础数据类型直接在栈空间分配，方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收。引用数据类型，需要用new来创建，既在栈空间 分配一个地址空间，又在堆空间分配对象的类变量 。方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。局部变量new出来时，在栈空间和堆空间中分配空 间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。方法调用时传入的literal参数，先在栈空间分配，在方法调用完成后从栈 空间分配。字符串常量在DATA区域分配，this在堆空间分配。数组既在栈空间分配数组名称，又在堆空间分配数组实际的大小！</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring boot入门【二】]]></title>
        <id>https://flakkaqi.github.io/post/spring-boot-ru-men-er/</id>
        <link href="https://flakkaqi.github.io/post/spring-boot-ru-men-er/">
        </link>
        <updated>2020-06-22T05:50:17.000Z</updated>
        <summary type="html"><![CDATA[<p>利用Springboot构建应用程序</p>
]]></summary>
        <content type="html"><![CDATA[<p>利用Springboot构建应用程序</p>
<!-- more -->
<h3 id="一-首先在httpsstartspringio-生成一个基础的springboot项目">一、首先在https://start.spring.io/ 生成一个基础的springboot项目</h3>
<h3 id="二-编写spring-boot启动类">二、编写Spring boot启动类</h3>
<p>step1：在com.example.springboot包下创建Application.java</p>
<pre><code>package com.example.sprinboot;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

import java.util.Arrays;

/**
 * @Auther: QiShuai
 * @Date: 2020/6/22 14:31
 * @Description: springboot的启动类
 */
//@SpringBootApplication 以下几个注解的简单写法
@Configuration //标记这个类作为应用上下文bean定义的源
@EnableAutoConfiguration //告诉springboot根据类路径设置、其他bean和各种属性设置开始添加bean
@ComponentScan  //告诉spring在指定包中寻找其他组件，配置和服务，让他找到控制器controller
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args); //springboot启动应用程序的方法
    }

    //排序并打印所有由您的应用程序创建或者由springboot自动添加的所有bean。
    @Bean
    public CommandLineRunner commandLineRunner(ApplicationContext ctx) {
        return args -&gt; {
            System.out.println(&quot;Let's inspect the beans provided by Spring Boot:&quot;);
            String[] beanNames = ctx.getBeanDefinitionNames();
            Arrays.sort(beanNames);
            for (String beanName : beanNames) {
                System.out.println(beanName);
            }
        };
    }
}
</code></pre>
<p>step2：在com.example.springboot创建一个控制器HelloController.java</p>
<pre><code>package com.example.sprinboot;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Auther: QiShuai
 * @Date: 2020/6/22 14:22
 * @Description:
 */
//该注解意味着该类可以由Spring MVC使用来处理Web请求，@Controller+@ResponseBody返回数据而不是视图
@RestController
public class HelloController {

    //该注解映射路径&quot;/&quot;index()方法上，从浏览器调用或者在命令行上使用curl时，该方法返回纯文本
    @RequestMapping(&quot;/&quot;)
    public String index() {
        return &quot;Greetings from Spring Boot!&quot;;
    }
}
</code></pre>
<p>step3：运行springboot启动类</p>
<pre><code>mvnw springt-boot:run
打印出所有的bean
</code></pre>
<p>step4：打开控制台使用curl调用该接口</p>
<pre><code>curl localhost:8080
Greetings from Spring Boot!
</code></pre>
<h3 id="三-添加单元测试">三、添加单元测试</h3>
<p>step1：添加sprinboot-test依赖</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
	&lt;exclusions&gt;
		&lt;exclusion&gt;
			&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
			&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
		&lt;/exclusion&gt;
	&lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>step2：此处介绍两种单元测试方式，一定要注意，测试包路径一定要和被测试的包路径保持一致。<br>
step2-1：模拟Http请求周期，编写简单的全栈测试</p>
<pre><code>package com.example.springboot;

import static org.assertj.core.api.Assertions.*;

import java.net.URL;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.http.ResponseEntity;

/**
 * @Auther: QiShuai
 * @Date: 2020/6/22 15:50
 * @Description: 模拟Http请求周期，编写简单的全栈测试
 */
//嵌入式服务器从一个随机端口启动，并在运行时使用 @LocalServerPort发现的真实端口
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = Application.class)
public class HelloControllerT {
    @LocalServerPort
    private int port;

    private URL base;

    @Autowired
    private TestRestTemplate template;

    @BeforeEach
    public void setUp() throws Exception {
        this.base = new URL(&quot;http://localhost:&quot; + port + &quot;/&quot;);
    }

    @Test
    public void getHello() throws Exception {
        ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(),
                String.class);
        assertThat(response.getBody()).isEqualTo(&quot;Greetings from Spring Boot!&quot;);
    }
}
</code></pre>
<p>step2-2：模拟通过断点的servlet请求和响应</p>
<pre><code>package com.example.springboot;

import static org.hamcrest.Matchers.equalTo;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
/**
 * @Auther: QiShuai
 * @Date: 2020/6/22 15:20
 * @Description: 模拟通过断点的servlet请求和响应
 */
//以下两个注解作用是注入MockMvc实例
@SpringBootTest(classes = Application.class)  //使用该注解的话要求创建整个应用程序上下文
@AutoConfigureMockMvc
public class HelloControllerTest {

    @Autowired
    private MockMvc mvc;  //通过一组便捷的构建器类将http请求发送到DispatcherServlet并对结果断言

    @Test
    public void getHello() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;)
                .accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk())
                .andExpect(content().string(equalTo(&quot;Greetings from Spring Boot!&quot;)));
    }
}
</code></pre>
<h3 id="四-添加生产级服务">四、添加生产级服务</h3>
<p>springboot的执行器模块提供多种管理服务（比如运行状态、审计、Bean等）<br>
step1：添加依赖</p>
<pre><code>&lt;!--springboot的执行器模块提供多种管理服务（比如运行状态、审计、Bean等）--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>step2： 检查应用程序的运行状态</p>
<pre><code>$ curl localhost:8080/actuator/health
{&quot;status&quot;:&quot;UP&quot;}
</code></pre>
<p>step3：其他的参阅<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready-endpoints">端点</a></p>
<h3 id="五-springboot-源代码">五、Springboot 源代码</h3>
<p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters">Spring boot源代码</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring boot 入门【一】]]></title>
        <id>https://flakkaqi.github.io/post/spring-boot/</id>
        <link href="https://flakkaqi.github.io/post/spring-boot/">
        </link>
        <updated>2020-06-22T01:44:36.000Z</updated>
        <summary type="html"><![CDATA[<p>springboot开始第一天👶</p>
]]></summary>
        <content type="html"><![CDATA[<p>springboot开始第一天👶</p>
<!-- more -->
<h2 id="一-概述">一、 概述</h2>
<p>springboot 会让你非常容易的创建一个独立的生产级spring基础应用，而且对于它你能做的就是“开始运行”,我们采用了spring平台自主的视图和第三方文库，这样你会做最少的无用功。spring boot应用只需要非常少的配置。</p>
<h3 id="1-特点">1、特点</h3>
<pre><code>1.创建独立的Spring应用程序
2.直接嵌入Tomcat，Jetty或Undertow（无需部署WAR文件）
3.提供入门级的依赖文件来简化您的构建配置
4.尽可能的自动配置Spring和第三方库
5.提供可用于生产的功能，如指标，运行状况检查和外部配置
6.完全不会生成代码，也不需要XML配置
</code></pre>
<h3 id="2快速入门">2.快速入门</h3>
<p>step1：开始一个新的spring boot项目</p>
<pre><code>使用https://start.spring.io/ 创建一个新的WEB项目，并添加web依赖。下载压缩包到本地。
勾选示例：maven project、2.3.1、jar、8、Spring Web
</code></pre>
<p>step2：添加你的代码</p>
<pre><code>
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
//The @RestController annotation tells Spring that this code describes an endpoint that should be made available over the web.
@RestController
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    //The @GetMapping(“/hello”) tells Spring to use our hello() method to answer requests that get sent to the http://localhost:8080/hello address.
    @GetMapping(&quot;/hello&quot;)
    //the @RequestParam is telling Spring to expect a name value in the request, but if it’s not there, it will use the word “World” by default.
    public String hello(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;) String name) {
        return String.format(&quot;Hello %s!&quot;, name);
    }
}
  
</code></pre>
<p>The @RestController annotation tells Spring that this code describes an endpoint that should be made available over the web. The @GetMapping(“/hello”) tells Spring to use our hello() method to answer requests that get sent to the http://localhost:8080/hello address. Finally, the @RequestParam is telling Spring to expect a name value in the request, but if it’s not there, it will use the word “World” by default.</p>
<p>step3：启动项目<br>
打开控制台执行启动命令</p>
<pre><code>mvnw spring-boot:run
</code></pre>
<p>step4：在浏览器调用接口<br>
项目启动后我们会看到如下信息</p>
<p><img src="https://flakkaqi.github.io/post-images/1592797368807.png" alt="" loading="lazy"><br>
端口为 8080<br>
可以在浏览器端输入地址：http://localhost:8080/hello?name=amy进行接口调用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[身份证校验规则]]></title>
        <id>https://flakkaqi.github.io/post/shen-fen-zheng-xiao-yan-gui-ze/</id>
        <link href="https://flakkaqi.github.io/post/shen-fen-zheng-xiao-yan-gui-ze/">
        </link>
        <updated>2020-06-20T07:51:20.000Z</updated>
        <content type="html"><![CDATA[<pre><code>     * 身份证15位编码规则：dddddd yymmdd xx p
     * dddddd：6位地区编码
     * yymmdd: 出生年(两位年)月日，如：910215
     * xx: 顺序编码，系统产生，无法确定
     * p: 性别，奇数为男，偶数为女
     * 身份证18位编码规则：dddddd yyyymmdd xxx y
     * dddddd：6位地区编码
     * yyyymmdd: 出生年(四位年)月日，如：19910215
     * xxx：顺序编码，系统产生，无法确定，奇数为男，偶数为女
     * y: 校验码，该位数值可通过前17位计算获得
     * 前17位号码加权因子为 Wi = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ]
     * 验证位 Y = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ]
     * 如果验证码恰好是10，为了保证身份证是十八位，那么第十八位将用X来代替
     * 校验位计算公式：Y_P = mod( ∑(Ai×Wi),11 )
     * i为身份证号码1...17 位; Y_P为校验码Y所在校验码数组位置
</code></pre>
<pre><code class="language-js">         function validateIdCard(idCard){
            //15位和18位身份证号码的正则表达式
            var regIdCard=/^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/;
            //如果通过该验证，说明身份证格式正确，但准确性还需计算
            if(regIdCard.test(idCard)){
                if(idCard.length==18){
                    var idCardWi=new Array( 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ); //将前17位加权因子保存在数组里
                    var idCardY=new Array( 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ); //这是除以11后，可能产生的11位余数、验证码，也保存成数组
                    var idCardWiSum=0; //用来保存前17位各自乖以加权因子后的总和
                    for(var i=0;i&lt;17;i++){
                        idCardWiSum+=idCard.substring(i,i+1)*idCardWi[i];
                    }
                    var idCardMod=idCardWiSum%11;//计算出校验码所在数组的位置
                    var idCardLast=idCard.substring(17);//得到最后一位身份证号码
                    //如果等于2，则说明校验码是10，身份证号码最后一位应该是X
                    if(idCardMod==2){
                        if(idCardLast==&quot;X&quot;||idCardLast==&quot;x&quot;){
                            alert(&quot;恭喜通过验证啦！&quot;);
                        }else{
                            alert(&quot;身份证号码错误！&quot;);
                        }
                    }else{
                        //用计算出的验证码与最后一位身份证号码匹配，如果一致，说明通过，否则是无效的身份证号码
                        if(idCardLast==idCardY[idCardMod]){
                            alert(&quot;恭喜通过验证啦！&quot;);
                        }else{
                            alert(&quot;身份证号码错误！&quot;);
                        }
                    }
                }
            }else{
                alert(&quot;身份证格式不正确!&quot;);
            }
        }
    ``` 
![](https://flakkaqi.github.io/post-images/1592639889017.png)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot+mybatis+swaager]]></title>
        <id>https://flakkaqi.github.io/post/springbootmybatisswaager/</id>
        <link href="https://flakkaqi.github.io/post/springbootmybatisswaager/">
        </link>
        <updated>2020-06-09T06:25:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring Boot使用MyBatis Generator、Swagger、MyBatis是Java目前主流的ORM框架，可以参考这篇文章：<a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boot-mybatis.html">在Spring Boot中使用MyBatis</a><br>
这篇文章来将介绍MyBatis Generator，（简称MBG，下文使用这个简称），该插件可以很方便的生成实体类、Mapper接口代码等，提高开发效率，它有点像.NET的EF框架中的DB First。另外，顺便介绍Spring Boot如何集成Swagger。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring Boot使用MyBatis Generator、Swagger、MyBatis是Java目前主流的ORM框架，可以参考这篇文章：<a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boot-mybatis.html">在Spring Boot中使用MyBatis</a><br>
这篇文章来将介绍MyBatis Generator，（简称MBG，下文使用这个简称），该插件可以很方便的生成实体类、Mapper接口代码等，提高开发效率，它有点像.NET的EF框架中的DB First。另外，顺便介绍Spring Boot如何集成Swagger。</p>
<!-- more -->
<p><a href="https://www.cnblogs.com/FireworksEasyCool/p/11133827.html">点击跳转参考文章</a></p>
<h2 id="一-创建mysql数据库">一、创建MySQL数据库</h2>
<pre><code class="language-sql">create database generatortest default character set utf8mb4 collate utf8mb4_unicode_ci;
use generatortest;
create user 'generatortest'@'localhost' identified by 'generatortest123';
grant all privileges on generatortest.* to 'generatortest'@'localhost';
flush privileges;

CREATE TABLE `user`
(
  id INT NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  user_name VARCHAR(50) NOT NULL COMMENT '用户名',
  `password` VARCHAR(50) NOT NULL COMMENT '密码',
  email VARCHAR(50) COMMENT '邮箱',
  avatar VARCHAR(255) COMMENT '头像',
  create_time DATETIME NOT NULL COMMENT '创建时间',
    update_time DATETIME NOT NULL COMMENT '更新时间',
    deleted TINYINT(1) default 0 COMMENT '逻辑删除',
  PRIMARY KEY (id)
);
ALTER TABLE `user` COMMENT '用户表';

CREATE TABLE role
(
  id INT NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  role_name VARCHAR(50) NOT NULL COMMENT '角色名',
  enabled TINYINT(1) default 1 NOT NULL COMMENT '有效标志',
  create_time DATETIME NOT NULL COMMENT '创建时间',
    update_time DATETIME NOT NULL COMMENT '更新时间',
    deleted TINYINT(1) default 0 NOT NULL COMMENT '逻辑删除',
  PRIMARY KEY (id)
);
ALTER TABLE role COMMENT '角色表';

CREATE TABLE permission
(
  id INT NOT NULL AUTO_INCREMENT COMMENT '权限ID',
  permission_name VARCHAR(50) NOT NULL COMMENT '权限名称',
  permission_value VARCHAR(200) NOT NULL COMMENT '权限值',
  PRIMARY KEY (id)
);
ALTER TABLE permission COMMENT '权限表';

CREATE TABLE user_role
(
  user_id INT NOT NULL COMMENT '用户ID',
  role_id INT NOT NULL COMMENT '角色ID'
);
ALTER TABLE user_role COMMENT '用户角色关联表';

CREATE TABLE role_permission
(
  role_id INT NOT NULL COMMENT '角色ID',
  permission_id INT NOT NULL COMMENT '权限ID'
);
ALTER TABLE role_permission COMMENT '角色权限关联表';
</code></pre>
<h2 id="二-创建maven项目">二、创建maven项目</h2>
<h3 id="1-创建maven工程">1、创建maven工程</h3>
<p>可以参考<a href="https://www.cnblogs.com/qinxu/p/9648429.html">idea创建maven项目</a></p>
<h3 id="2-pomxml">2、pom.xml</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.0.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
            &lt;version&gt;1.3.7&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    ```
### 3、

![](https://flakkaqi.github.io/post-images/1592639968494.webp)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot创建定时任务]]></title>
        <id>https://flakkaqi.github.io/post/springboot-chuang-jian-ding-shi-ren-wu/</id>
        <link href="https://flakkaqi.github.io/post/springboot-chuang-jian-ding-shi-ren-wu/">
        </link>
        <updated>2020-06-09T03:43:42.000Z</updated>
        <summary type="html"><![CDATA[<p>😕最简单的定时任务。定时时间最好放在配置文件里。</p>
]]></summary>
        <content type="html"><![CDATA[<p>😕最简单的定时任务。定时时间最好放在配置文件里。</p>
<!-- more -->
<h3 id="定时任务">定时任务</h3>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

@Configuration      //1.主要用于标记配置类，兼备Component的效果。
@EnableScheduling   // 2.开启定时任务
public class QuestionnaireTimingJob {

    private static final Logger logger = LoggerFactory.getLogger(QuestionnaireTimingJob.class);

    @Value(&quot;${task.questionnaireJob.baseRestUrl}&quot;)
    private String baseUrl;

    @Scheduled(cron = &quot;${task.questionnaireJob.corn}&quot;)
    public void process() {
        logger.info(&quot;执行静态定时任务:xxxxxxx&quot;+ LocalDateTime.now());
    }
}
</code></pre>
<h3 id="配置文件application-jobyml">配置文件：application-job.yml</h3>
<pre><code class="language-yml">task:
  questionnaireJob:
    corn: 0 0 23 * * ?
    baseRestUrl：http://xxxx.xxx.cclssksls.cclslls/skss/
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://flakkaqi.github.io/post-images/1591674724449.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>